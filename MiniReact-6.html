<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mini React v5 Interactive Demo</title>
</head>
<body>
  <div id="root" style="border:1px solid #000; padding:10px;"></div>
  <div id="portal-root" style="border:1px solid red; padding:10px; margin-top:10px;"></div>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel" data-plugins="transform-react-jsx" data-react-pragma="createElement" data-react-pragma-fragment="Fragment">
    /**
     * @jsx createElement
     * @jsxFrag Fragment
     */

    const Fragment = Symbol('Fragment');
    const Portal = Symbol('Portal');

    let state = [];
    let stateIndex = 0;
    let effectDeps = [];
    let cleanupEffects = [];

    function useState(initial) {
      const idx = stateIndex;
      state[idx] = state[idx] ?? initial;
      function setState(newState) {
        state[idx] = newState;
        scheduleRender();
      }
      stateIndex++;
      return [state[idx], setState];
    }

    function useEffect(callback, deps) {
      const idx = stateIndex;
      const prevDeps = effectDeps[idx];
      let changed = true;
      if (prevDeps) changed = deps.some((d,i)=>d!==prevDeps[i]);
      if(changed){
        if(cleanupEffects[idx]) cleanupEffects[idx]();
        const cleanup = callback();
        cleanupEffects[idx] = typeof cleanup === 'function'?cleanup:null;
        effectDeps[idx] = deps;
      }
      stateIndex++;
    }

    function createElement(tag, props, ...children) {
      return { tag, props: props || {}, children: children.flat() };
    }

    // Fiber-like async render
    let nextUnitOfWork = null;
    let wipRoot = null;
    let containerRoot = document.getElementById('root');
    let prevVNode = null;

    function scheduleRender() {
      wipRoot = { vnode: <App />, container: containerRoot, prevVNode: prevVNode };
      nextUnitOfWork = wipRoot;
      requestIdleCallback(workLoop);
    }

    function workLoop(deadline){
      while(nextUnitOfWork && deadline.timeRemaining() > 1){
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
      if(nextUnitOfWork) requestIdleCallback(workLoop);
      else if(wipRoot) commitRoot();
    }

    function performUnitOfWork(fiber){
      fiber.el = renderVNode(fiber.vnode, fiber.container, fiber.prevVNode);
      return null; // simplified
    }

    function commitRoot(){
      prevVNode = wipRoot.el;
      wipRoot = null;
    }

    /**
     * 渲染虚拟节点到指定容器中，支持与旧虚拟节点进行比较以实现差异更新
     * @param {object|string|number} vnode - 当前要渲染的虚拟节点
     * @param {HTMLElement} container - 渲染的目标容器
     * @param {object|null} oldVNode - 旧的虚拟节点，用于差异比较，默认为 null
     * @returns {object|null} 渲染后的节点信息，若 vnode 为空则返回 null
     */
    function renderVNode(vnode, container, oldVNode=null){
      // 如果当前虚拟节点为空，则移除旧节点并返回 null
      if(!vnode){
        if(oldVNode && oldVNode.el) container.removeChild(oldVNode.el);
        return null;
      }

      // 处理文本节点
      if(typeof vnode === 'string'||typeof vnode==='number'){
        // 如果旧节点也是文本节点，比较内容并更新
        if(oldVNode && oldVNode.type==='text'){
          if(oldVNode.text!==vnode) oldVNode.el.textContent=vnode;
          return {...oldVNode, text:vnode};
        }
        // 创建新的文本节点并添加到容器中
        const el=document.createTextNode(vnode);
        container.appendChild(el);
        return {type:'text', el, text:vnode};
      }

      // 处理组件节点
      if(typeof vnode.tag==='function'){
        // 调用组件函数获取新的虚拟节点
        const compVNode=vnode.tag({...vnode.props, children:vnode.children});
        // 递归渲染新的虚拟节点，传递旧节点的子节点用于比较
        return renderVNode(compVNode, container, oldVNode?oldVNode.child:null);
      }

      // 处理 Fragment 节点
      if(vnode.tag===Fragment){
        const childrenNodes=[];
        // 递归渲染所有子节点
        vnode.children.forEach((child,i)=>{
          childrenNodes.push(renderVNode(child, container, oldVNode?oldVNode.children[i]:null));
        });
        return {type:Fragment, children:childrenNodes};
      }

      // 处理 Portal 节点
      if(vnode.tag===Portal){
        const portalContainer=vnode.props.container;
        const childrenNodes=[];
        // 递归渲染所有子节点到指定的 Portal 容器中
        vnode.children.forEach((child,i)=>{
          childrenNodes.push(renderVNode(child, portalContainer, oldVNode?oldVNode.children[i]:null));
        });
        return {type:Portal, children:childrenNodes};
      }

      let el;
      // 如果旧节点存在且类型匹配，则复用旧节点的 DOM 元素
      if(oldVNode && oldVNode.el && oldVNode.type===vnode.tag) el=oldVNode.el;
      else{
        // 创建新的 DOM 元素
        el=document.createElement(vnode.tag);
        if(oldVNode && oldVNode.el) container.replaceChild(el, oldVNode.el);
        else container.appendChild(el);
      }

      // 获取旧节点的属性
      const oldProps=(oldVNode && oldVNode.props)||{};
      // 更新新节点的属性
      for(const key in vnode.props){
        // 处理事件监听器
        if(key.startsWith('on') && typeof vnode.props[key]==='function'){
          if(oldProps[key]!==vnode.props[key]){
            if(oldProps[key]) el.removeEventListener(key.slice(2).toLowerCase(), oldProps[key]);
            el.addEventListener(key.slice(2).toLowerCase(), vnode.props[key]);
          }
        } 
        // 处理 style 属性
        else if(key==='style' && typeof vnode.props[key]==='object'){
          Object.assign(el.style, vnode.props[key]);
        } 
        // 处理其他属性
        else {
          if(oldProps[key]!==vnode.props[key]) el.setAttribute(key,vnode.props[key]);
        }
      }
      // 移除旧节点中存在但新节点中不存在的属性
      for(const key in oldProps){
        if(!(key in vnode.props)){
          if(key.startsWith('on')) el.removeEventListener(key.slice(2).toLowerCase(), oldProps[key]);
          else el.removeAttribute(key);
        }
      }

      // Children diff with key
      const oldChildren=(oldVNode && oldVNode.children)||[];
      const newChildren=[];
      const keyedOld={};
      oldChildren.forEach(c=>{if(c&&c.props&&c.props.key!=null) keyedOld[c.props.key]=c;});

      vnode.children.forEach((child,i)=>{
        let oldChild=null;
        if(child && child.props && child.props.key!=null) oldChild=keyedOld[child.props.key]||null;
        else oldChild=oldChildren[i]||null;
        newChildren.push(renderVNode(child, el, oldChild));
      });

      return {type:vnode.tag, el, props:vnode.props, children:newChildren};
    }

    /*** Demo Components ***/
    function Counter({initial=0}){
      const [count,setCount]=useState(initial);
      useEffect(()=>{console.log('Counter',count); return ()=>console.log('Cleanup',count);},[count]);
      return (
        <div>
          <h3>Counter: {count}</h3>
          <button onClick={()=>setCount(count+1)}>+</button>
          <button onClick={()=>setCount(count-1)}>-</button>
        </div>
      );
    }

    function App(){
      const [text,setText]=useState('Mini React v5 Interactive');
      const [items,setItems]=useState([
        {id:1,text:'Apple'},
        {id:2,text:'Banana'},
      ]);

      function addItem(){
        const nextId=items.length+1;
        setItems([...items,{id:nextId,text:`Item ${nextId}`}]);
      }

      function removeItem(id){
        setItems(items.filter(i=>i.id!==id));
      }

      function shuffle(){
        setItems([...items].sort(()=>Math.random()-0.5));
      }

      return (
        <>
          <h1>Mini React v5 Interactive Demo</h1>
          <input value={text} onInput={e=>setText(e.target.value)}/>
          <p>You typed: {text}</p>
          <Counter initial={5}/>
          <button onClick={addItem}>Add Item</button>
          <button onClick={shuffle}>Shuffle Items</button>
          <ul>
            {items.map(item=>
              <li key={item.id}>
                {item.text} <button onClick={()=>removeItem(item.id)}>Remove</button>
              </li>
            )}
          </ul>
          <Portal container={document.getElementById('portal-root')}>
            <p>This is rendered via Portal!</p>
          </Portal>
        </>
      );
    }

    // Initialize app
    scheduleRender();
  </script>
</body>
</html>
