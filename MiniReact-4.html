<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mini React v4 with key diff</title>
</head>
<body>
  <div id="root"></div>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    /*** Mini React v4: 完整 key diff 列表支持 ***/

    let state = [];
    let stateIndex = 0;
    let effectDeps = [];
    let cleanupEffects = [];

    function useState(initial) {
      const currentIndex = stateIndex;
      state[currentIndex] = state[currentIndex] ?? initial;

      function setState(newState) {
        state[currentIndex] = newState;
        rerender();
      }

      stateIndex++;
      return [state[currentIndex], setState];
    }

    function useEffect(callback, deps) {
      const currentIndex = stateIndex;
      const prevDeps = effectDeps[currentIndex];
      let hasChanged = true;

      if (prevDeps) {
        hasChanged = deps.some((d, i) => d !== prevDeps[i]);
      }

      if (hasChanged) {
        if (cleanupEffects[currentIndex]) cleanupEffects[currentIndex]();
        const cleanup = callback();
        cleanupEffects[currentIndex] = typeof cleanup === 'function' ? cleanup : null;
        effectDeps[currentIndex] = deps;
      }

      stateIndex++;
    }

   /**
     * @jsx createElement
     */
    function createElement(tag, props, ...children) {
      return { tag, props: props || {}, children: children.flat() };
    }

    /*** DOM diff 核心函数，支持 key ***/
    function render(vnode, container, oldVNode = null) {
      if (!vnode) {
        if (oldVNode && oldVNode.el) container.removeChild(oldVNode.el);
        return null;
      }

      // 文本节点
      if (typeof vnode === 'string' || typeof vnode === 'number') {
        if (oldVNode && oldVNode.type === 'text') {
          if (oldVNode.text !== vnode) oldVNode.el.textContent = vnode;
          return { ...oldVNode, text: vnode };
        }
        const el = document.createTextNode(vnode);
        container.appendChild(el);
        return { type: 'text', el, text: vnode };
      }

      // 函数组件
      if (typeof vnode.tag === 'function') {
        const compVNode = vnode.tag({ ...vnode.props, children: vnode.children });
        return render(compVNode, container, oldVNode ? oldVNode.child : null);
      }

      // 普通元素
      let el;
      if (oldVNode && oldVNode.el && oldVNode.type === vnode.tag) {
        el = oldVNode.el;
      } else {
        el = document.createElement(vnode.tag);
        if (oldVNode && oldVNode.el) container.replaceChild(el, oldVNode.el);
        else container.appendChild(el);
      }

      // 属性和事件绑定
      const oldProps = (oldVNode && oldVNode.props) || {};
      for (const key in vnode.props) {
        if (key.startsWith('on') && typeof vnode.props[key] === 'function') {
          if (oldProps[key] !== vnode.props[key]) {
            if (oldProps[key]) el.removeEventListener(key.slice(2).toLowerCase(), oldProps[key]);
            el.addEventListener(key.slice(2).toLowerCase(), vnode.props[key]);
          }
        } else if (key === 'style' && typeof vnode.props[key] === 'object') {
          Object.assign(el.style, vnode.props[key]);
        } else {
          if (oldProps[key] !== vnode.props[key]) el.setAttribute(key, vnode.props[key]);
        }
      }
      for (const key in oldProps) {
        if (!(key in vnode.props)) {
          if (key.startsWith('on')) el.removeEventListener(key.slice(2).toLowerCase(), oldProps[key]);
          else el.removeAttribute(key);
        }
      }

      // 子节点 diff，支持 key
      const oldChildren = (oldVNode && oldVNode.children) || [];
      const newChildren = [];
      const keyedOld = {};
      oldChildren.forEach(c => {
        if (c && c.props && c.props.key != null) keyedOld[c.props.key] = c;
      });

      let lastPlacedIndex = 0;
      vnode.children.forEach((childVNode, i) => {
        let oldChild = null;
        if (childVNode && childVNode.props && childVNode.props.key != null) {
          oldChild = keyedOld[childVNode.props.key] || null;
        } else {
          oldChild = oldChildren[i] || null;
        }

        const newChild = render(childVNode, el, oldChild);
        newChildren.push(newChild);
      });

      return { type: vnode.tag, el, props: vnode.props, children: newChildren };
    }

    const container = document.getElementById('root');
    let AppComponent = null;
    let prevVNode = null;

    function createApp(App) {
      AppComponent = App;
      rerender();
    }

    function rerender() {
      stateIndex = 0;
      prevVNode = render(<AppComponent />, container, prevVNode);
    }

    /*** 示例组件 ***/
    function Counter({ initial = 0 }) {
      const [count, setCount] = useState(initial);

      useEffect(() => {
        console.log('Count updated:', count);
        return () => console.log('Cleanup count:', count);
      }, [count]);

      return (
        <div>
          <h2>Counter: {count}</h2>
          <button onClick={() => setCount(count + 1)}>+</button>
          <button onClick={() => setCount(count - 1)}>-</button>
        </div>
      );
    }

    function App() {
      const [text, setText] = useState('Mini React v4');
      const [items, setItems] = useState([
        { id: 1, text: 'Apple' },
        { id: 2, text: 'Banana' },
      ]);

      function addItem() {
        const nextId = items.length + 1;
        setItems([...items, { id: nextId, text: `Item ${nextId}` }]);
      }

      return (
        <div>
          <h1>Mini React v4 Demo</h1>
          <input value={text} onInput={e => setText(e.target.value)} />
          <p>You typed: {text}</p>
          <Counter initial={5} />
          <button onClick={addItem}>Add Item</button>
          <ul>
            {items.map(item => <li key={item.id}>{item.text}</li>)}
          </ul>
        </div>
      );
    }

    createApp(App);
  </script>
</body>
</html>
